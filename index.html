<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>AdaptiveDensityApproximation · AdaptiveDensityApproximation.jl</title><meta name="title" content="AdaptiveDensityApproximation · AdaptiveDensityApproximation.jl"/><meta property="og:title" content="AdaptiveDensityApproximation · AdaptiveDensityApproximation.jl"/><meta property="twitter:title" content="AdaptiveDensityApproximation · AdaptiveDensityApproximation.jl"/><meta name="description" content="Documentation for AdaptiveDensityApproximation.jl."/><meta property="og:description" content="Documentation for AdaptiveDensityApproximation.jl."/><meta property="twitter:description" content="Documentation for AdaptiveDensityApproximation.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.svg" alt="AdaptiveDensityApproximation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>AdaptiveDensityApproximation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>AdaptiveDensityApproximation</a><ul class="internal"><li><a class="tocitem" href="#About"><span>About</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Construct-a-grid-and-approximate-densities"><span>Construct a grid and approximate densities</span></a></li><li><a class="tocitem" href="#Accessing-information-of-the-grid"><span>Accessing information of the grid</span></a></li><li><a class="tocitem" href="#Refine-the-grid"><span>Refine the grid</span></a></li><li><a class="tocitem" href="#Restriction-of-grid-domain"><span>Restriction of grid domain</span></a></li><li><a class="tocitem" href="#Simple-calculations:-Sums,-products-and-integrals"><span>Simple calculations: Sums, products and integrals</span></a></li><li><a class="tocitem" href="#Advanced-calculations:-Integral-models"><span>Advanced calculations: Integral models</span></a></li><li><a class="tocitem" href="#PDF-and-CDF"><span>PDF and CDF</span></a></li><li><a class="tocitem" href="#Simple-2-dim-example"><span>Simple 2-dim example</span></a></li></ul></li><li><span class="tocitem">Plotting grids</span><ul><li><a class="tocitem" href="plotting_basics/">Plotting basics</a></li><li><a class="tocitem" href="plotting_keywords/">Plotting options</a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>AdaptiveDensityApproximation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>AdaptiveDensityApproximation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AntibodyPackages/AdaptiveDensityApproximation" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AntibodyPackages/AdaptiveDensityApproximation/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="AdaptiveDensityApproximation"><a class="docs-heading-anchor" href="#AdaptiveDensityApproximation">AdaptiveDensityApproximation</a><a id="AdaptiveDensityApproximation-1"></a><a class="docs-heading-anchor-permalink" href="#AdaptiveDensityApproximation" title="Permalink"></a></h1><h2 id="About"><a class="docs-heading-anchor" href="#About">About</a><a id="About-1"></a><a class="docs-heading-anchor-permalink" href="#About" title="Permalink"></a></h2><p><a href="https://github.com/AntibodyPackages/AdaptiveDensityApproximation.jl"><code>AdaptiveDensityApproximation.jl</code></a> introduces the types <code>OneDimGrid</code> and<code>Grid</code> that can be refined adaptively for the approximation of density functions. Simple calculations are implemented, e.g. the sum and product of approximated density coefficients or a rudimentary numerical integration of approximated densities. Integral models can be approximated for the inference of densities. In case of probability densities, empirical PDF and CDF functions can be constructed.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The package can be installed with the following commands</p><pre><code class="language-julia hljs">using Pkg
Pkg.Registry.add()
Pkg.Registry.add(RegistrySpec(url = &quot;https://github.com/AntibodyPackages/AntibodyPackagesRegistry&quot;))
Pkg.add(&quot;AdaptiveDensityApproximation&quot;)</code></pre><p>Since the package is not part of the <code>General</code> registry the commands install the additional registry <code>AntibodyPackagesRegistry</code> first.</p><p>After the installation, the package can be used like any other package:</p><pre><code class="language-julia hljs">using AdaptiveDensityApproximation</code></pre><p>In the following, the methods of this package are illustrated with simple, 1-dimensional examples. For a full documentation of the methods, see the <a href="api/">API</a></p><div class="admonition is-success"><header class="admonition-header">Tip: Plotting grids</header><div class="admonition-body"><p>This package does not include any plotting methods, to reduce the dependencies. However, the <a href="https://github.com/AntibodyPackages/AdaptiveDensityApproximationRecipes.jl"><code>AdaptiveDensityApproximationRecipes.jl</code></a> contains plotting recipes for <a href="https://docs.juliaplots.org/stable/"><code>Plots.jl</code></a>. Assuming that the <code>AntibodyPackagesRegistry</code> is installed, the package can be installed like any other package:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;AdaptiveDensityApproximationRecipes&quot;)</code></pre></div></div><h2 id="Construct-a-grid-and-approximate-densities"><a class="docs-heading-anchor" href="#Construct-a-grid-and-approximate-densities">Construct a grid and approximate densities</a><a id="Construct-a-grid-and-approximate-densities-1"></a><a class="docs-heading-anchor-permalink" href="#Construct-a-grid-and-approximate-densities" title="Permalink"></a></h2><p>The first step is to create a new one-dimensional grid with <a href="api/#AdaptiveDensityApproximation.create_grid"><code>create_grid</code></a>. For this, axis-ticks need to be defined, i.e. the start/endpoints of the intervals:</p><pre><code class="language-julia hljs">using AdaptiveDensityApproximation, AdaptiveDensityApproximationRecipes, Plots
grid = create_grid(LinRange(0,2*pi,10))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AdaptiveDensityApproximation.OneDimGrid{Dict{String, AdaptiveDensityApproximation.OneDimBlock}}(Dict{String, AdaptiveDensityApproximation.OneDimBlock}(&quot;kPVxj2bLhi&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;kPVxj2bLhi&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(2.792526803190927, 3.490658503988659), [&quot;REGLOyaGkv&quot;, &quot;7aBwwsdR70&quot;], 1.0), &quot;XPuIXW2UsY&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;XPuIXW2UsY&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(4.1887902047863905, 4.886921905584122), [&quot;7aBwwsdR70&quot;, &quot;0S2WbxLh4e&quot;], 1.0), &quot;wl16U6a5uW&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;wl16U6a5uW&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(5.585053606381854, 6.283185307179586), [&quot;0S2WbxLh4e&quot;], 1.0), &quot;cUwJ3DcFam&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;cUwJ3DcFam&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.6981317007977318, 1.3962634015954636), [&quot;DBEZ1opxM6&quot;, &quot;d2OQL5p70J&quot;], 1.0), &quot;0S2WbxLh4e&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;0S2WbxLh4e&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(4.886921905584122, 5.585053606381854), [&quot;XPuIXW2UsY&quot;, &quot;wl16U6a5uW&quot;], 1.0), &quot;d2OQL5p70J&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;d2OQL5p70J&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(1.3962634015954636, 2.0943951023931953), [&quot;cUwJ3DcFam&quot;, &quot;REGLOyaGkv&quot;], 1.0), &quot;REGLOyaGkv&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;REGLOyaGkv&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(2.0943951023931953, 2.792526803190927), [&quot;d2OQL5p70J&quot;, &quot;kPVxj2bLhi&quot;], 1.0), &quot;7aBwwsdR70&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;7aBwwsdR70&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(3.490658503988659, 4.1887902047863905), [&quot;kPVxj2bLhi&quot;, &quot;XPuIXW2UsY&quot;], 1.0), &quot;DBEZ1opxM6&quot; =&gt; AdaptiveDensityApproximation.OneDimBlock(&quot;DBEZ1opxM6&quot;, AdaptiveDensityApproximation.Interval{Float64, Float64}(0.0, 0.6981317007977318), [&quot;cUwJ3DcFam&quot;], 1.0)))</code></pre><p>The grid can be used to approximate a density with <a href="api/#AdaptiveDensityApproximation.approximate_density!"><code>approximate_density!</code></a>:</p><pre><code class="language-julia hljs">approximate_density!(grid,sin)
plot(grid)
plot!(sin,color = :red, xlims = [0,2*pi], linewidth = 3, label = &quot;sin(x)&quot;)</code></pre><img src="index-4e6f4382.svg" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip: Approximation options</header><div class="admonition-body"><p>A density is approximated by evaluating the density-function at the center points of the grid. But in some cases, it can be desireable to approximate the density using different evaluation points. The following keywords allow to modify the approximation points:</p><ul><li><code>mode = :mean</code>: Use the average of the function values from the endpoints of the interval / corner points of the block.</li><li><code>mode = :mesh</code>: Use the average of the function values from a mesh of intermediate points.</li><li><code>mesh_size = n</code>: If <code>mode = :mesh</code> use <code>n</code> intermediate points (per dimension). The default is 4.</li></ul><p>It is also possible to approximate the area under the graph of a density (function value × block volume) by using <code>volume_normalization = true</code>.</p></div></div><h2 id="Accessing-information-of-the-grid"><a class="docs-heading-anchor" href="#Accessing-information-of-the-grid">Accessing information of the grid</a><a id="Accessing-information-of-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-information-of-the-grid" title="Permalink"></a></h2><p>Essentially, a grid is just a collection of values (the weights), together with location information (the blocks of the grid). This data can be exported to allow for a convenient implementation of advanced calculations not covered by this package. The weights can be exported with <a href="api/#AdaptiveDensityApproximation.export_weights"><code>export_weights</code></a>:</p><pre><code class="language-julia hljs">export_weights(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Float64}:
  0.3420201433256687
  0.8660254037844386
  0.9848077530122081
  0.6427876096865395
  1.2246467991473532e-16
 -0.6427876096865393
 -0.984807753012208
 -0.866025403784439
 -0.3420201433256686</code></pre><p>Alternatively, the full information can be exported with <a href="api/#AdaptiveDensityApproximation.export_all"><code>export_all</code></a>:</p><pre><code class="language-julia hljs">centers, volumes, weights = export_all(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0.3490658503988659, 1.0471975511965976, 1.7453292519943293, 2.443460952792061, 3.141592653589793, 3.839724354387525, 4.537856055185257, 5.235987755982988, 5.934119456780721], [0.6981317007977318, 0.6981317007977318, 0.6981317007977317, 0.6981317007977319, 0.6981317007977319, 0.6981317007977315, 0.6981317007977319, 0.6981317007977319, 0.6981317007977319], [0.3420201433256687, 0.8660254037844386, 0.9848077530122081, 0.6427876096865395, 1.2246467991473532e-16, -0.6427876096865393, -0.984807753012208, -0.866025403784439, -0.3420201433256686])</code></pre><p>The reverse direction, the import of weights is possible with <a href="api/#AdaptiveDensityApproximation.import_weights!"><code>import_weights!</code></a>:</p><pre><code class="language-julia hljs">import_weights!(grid, collect(1:9))
plot(grid)</code></pre><img src="index-519ac7e3.svg" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Order of blocks</header><div class="admonition-body"><p>For export and import, the intervals/blocks are ordered according to their center points. For multidimensional grids, the order is component wise (first dimension precedes second dimension precedes third dimension ...).</p></div></div><h2 id="Refine-the-grid"><a class="docs-heading-anchor" href="#Refine-the-grid">Refine the grid</a><a id="Refine-the-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Refine-the-grid" title="Permalink"></a></h2><p>The <a href="api/#AdaptiveDensityApproximation.refine!"><code>refine!</code></a> function subdivides the blocks that have the largest weight differences to their neighbors):</p><pre><code class="language-julia hljs">refine!(grid)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>A block is subdivided into 2^dim equally-sized subdividing blocks. E.g. an interval is split in the middle into two intervals, a square is split into 4 quartering squares, etc.. </p></div></div><p>The functions <a href="api/#AdaptiveDensityApproximation.approximate_density!"><code>approximate_density!</code></a> and <a href="api/#AdaptiveDensityApproximation.refine!"><code>refine!</code></a> can be used together in a loop to refine the grid adaptively.</p><pre><code class="language-julia hljs">grid = create_grid([0,pi/2,pi,3*pi/2,2*pi])

animation = @animate for i in 1:30
	plot(grid)
	plot!(sin,color = :red, xlims = [0,2*pi], linewidth = 3, label = &quot;sin(x)&quot;)
	approximate_density!(grid,sin)
	refine!(grid)
end
gif(animation,fps=2)</code></pre><img src="index-2c6fd080.gif" alt="Example block output"/><div class="admonition is-success"><header class="admonition-header">Tip: Custom variation and block selection</header><div class="admonition-body"><p>The refine process is a two-step process. First, each block is assigned a variation value. The default variation is the largest absolut weight difference to the neighboring blocks. Then, based on the variation values, the blocks that will be subdivided further get selected (largest variation value by default). However, it is possible to redefine the block variation assignment and the selection:</p><ul><li><code>block_variation</code>: Function to calculate the variation value for a block. Must use the following signature <code>(block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights)</code>.</li><li><code>selection</code>: Function to select which blocks need to be refined, based on their variation values. Must have the signature <code>(variations)</code>  where <code>variations</code> is a one-dim array of the variation values.</li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Weight splitting</header><div class="admonition-body"><p>The new subdividing blocks retain the weight of the original block. If <code>split_weights = true</code>, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).</p></div></div><h2 id="Restriction-of-grid-domain"><a class="docs-heading-anchor" href="#Restriction-of-grid-domain">Restriction of grid domain</a><a id="Restriction-of-grid-domain-1"></a><a class="docs-heading-anchor-permalink" href="#Restriction-of-grid-domain" title="Permalink"></a></h2><p>For some applications it can be useful to restrict a grid. Consider, for example, a grid that approximates <code>x-&gt;x^2</code> on the domain <code>[-2,2]</code>:</p><pre><code class="language-julia hljs">grid = create_grid(LinRange(-2,2,50))
approximate_density!(grid,x-&gt;x^2)
plot(grid)</code></pre><img src="index-c8bf3434.svg" alt="Example block output"/><p>The grid domain can be restricted to e.g. <code>[0,1]</code> with <a href="api/#AdaptiveDensityApproximation.restrict_domain!"><code>restrict_domain!</code></a>:</p><pre><code class="language-julia hljs">restrict_domain!(grid,lower = 0, upper = 1)
plot(grid)</code></pre><img src="index-585d8f25.svg" alt="Example block output"/><h2 id="Simple-calculations:-Sums,-products-and-integrals"><a class="docs-heading-anchor" href="#Simple-calculations:-Sums,-products-and-integrals">Simple calculations: Sums, products and integrals</a><a id="Simple-calculations:-Sums,-products-and-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-calculations:-Sums,-products-and-integrals" title="Permalink"></a></h2><p>Some simple operations are pre-defined for grids. For example, the sum and the product of the weights can easily be obtained.</p><pre><code class="language-julia hljs">sum(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4.331528529779258</code></pre><p>It is also possible to apply a function to all weights before they get summed up / get multiplied together. Furthermore, the grid domain can be restricted temporarily (not mutating the grid).</p><pre><code class="language-julia hljs">prod(x-&gt; log(x),grid, lower = 0.5, upper = 0.9)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.07335042343594485</code></pre><p>A grid can also be used for the approximation of an integral. In the case of the restricted grid from above, approximating <span>$x\mapsto x^2$</span> on <span>$[0,1]$</span>, the integral <span>$\int_0^{1} x^2\ dx = \frac{1}{3}$</span> can be approximated with <a href="api/#AdaptiveDensityApproximation.integrate"><code>integrate</code></a>:</p><pre><code class="language-julia hljs">integrate(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.33401048882693435</code></pre><h2 id="Advanced-calculations:-Integral-models"><a class="docs-heading-anchor" href="#Advanced-calculations:-Integral-models">Advanced calculations: Integral models</a><a id="Advanced-calculations:-Integral-models-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-calculations:-Integral-models" title="Permalink"></a></h2><p>A more flexible method of integration is the construction of integral models. Consider the general model</p><p class="math-container">\[	\int f(x,y,\varphi(y),...) \ dy\]</p><p>When the density <span>$\varphi$</span> is approximated by a grid, i.e. by blocks <span>$B_i$</span> with centers <span>$c_i$</span>, block volumes <span>$V_i$</span> and weights (function values) <span>$\lambda_i = \varphi(c_i)$</span>, the model can be approximated:</p><p class="math-container">\[	\int f(x,\tau,\varphi(y),...) \ dy \approx \sum_{i} f(x,c_i, \lambda_i,\ldots)\cdot V_i \ .\]</p><p>As simple example, consider <code>f(x,y,φ(y)) = cos(y * x) * φ(y)</code> with <code>φ(y) = sin(y)</code> for the domain <code>[0,2π]</code>:</p><p class="math-container">\[\int_0^{2\pi} \cos(y\cdot x)  \cdot \text{sin}(y) \ dy \ .\]</p><p>First, we construct a grid with domain <code>[0,2π]</code> and approximate the density <code>sin(y)</code>:</p><pre><code class="language-julia hljs">grid = create_grid(LinRange(0,2*pi,30))
approximate_density!(grid,sin)</code></pre><p>Next, we create the integral kernel <code>f</code> and create the approximated model with <a href="api/#AdaptiveDensityApproximation.integral_model"><code>integral_model</code></a>:</p><pre><code class="language-julia hljs">f(x,y,φ) = cos(y*x)*φ
approx_model,weights, block_functions = integral_model(grid,f)</code></pre><p>Finally, we can evaluate the model at <code>x = 1, λ = weights</code></p><pre><code class="language-julia hljs">approx_model(1,weights)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-6.938893903907228e-18</code></pre><p>The result can be checked analytically in this case:</p><p class="math-container">\[\int_0^{2\pi} \cos(y\cdot 1)  \cdot \text{sin}(y) \ dy = 0\ .\]</p><div class="admonition is-success"><header class="admonition-header">Approximated model and density estimation</header><div class="admonition-body"><p>The approximated model function <code>approx_model</code>  is a function of <code>(x,weights,...)</code>, where <code>weights</code> are the weights of the gird. However, instead of the grid <code>weights</code> any other array of the same length and data type can be used as argument. This allows to estimate a density by fitting the approximated model to data.</p></div></div><div class="admonition is-success"><header class="admonition-header">individual block functions and partial derivatives</header><div class="admonition-body"><p>The <code>block_functions</code> contain the functions for the individual blocks. That is, <code>block_functions</code> is an array of functions</p><p class="math-container">\[\left[(x,\lambda,\ldots) \longrightarrow V_i \cdot g(x,c_j,\lambda_j,\ldots) \qquad \text{for}\quad  i\quad  \text{in}\quad  1\colon n_{\text{blocks}} \right]\]</p><p>Instead of the integral kernel <code>f</code>, the optional third argument <code>g</code> is used: <code>integrate_model(grid,f,g)</code>. If no third argument is provided, the default case is <code>g=f</code>. This optional third argument can be used to construct the partial derivatives of the approximated model w.r.t. the parameters <span>$\lambda_j$</span>, by constructing <code>g</code> such that</p><p class="math-container">\[g(x,y,\varphi,\ldots) = \frac{\partial f(x,y,\varphi,\ldots)}{\partial \varphi} \]</p><p>This leads to the following <code>block_functions</code>:</p><p class="math-container">\[\left[(x,\lambda,\ldots) \longrightarrow V_i \cdot \left. \frac{\partial f(x,y,\varphi,\ldots)}{\partial \varphi}\right|_{(x,y,\varphi,\ldots) = (x,c_j,\lambda_j,\ldots)} \qquad \text{for}\quad  i\quad  \text{in}\quad  1\colon n_{\text{blocks}} \right]\]</p><p>It can easily be checked that these functions are the partial derivatives w.r.t. the parameters <span>$\lambda_j$</span> of the approximated model:</p><p class="math-container">\[\frac{\partial}{\partial \lambda_j} \sum_i V_i f(x,c_j,\lambda_j,\ldots) = V_i \frac{\partial}{\partial \lambda_j}  f(x,c_j,\lambda_j,\ldots) \equiv V_i \cdot \left. \frac{\partial f(x,y,\varphi,\ldots)}{\partial \varphi}\right|_{(x,y,\varphi,\ldots) = (x,c_j,\lambda_j,\ldots)}\]</p></div></div><h2 id="PDF-and-CDF"><a class="docs-heading-anchor" href="#PDF-and-CDF">PDF and CDF</a><a id="PDF-and-CDF-1"></a><a class="docs-heading-anchor-permalink" href="#PDF-and-CDF" title="Permalink"></a></h2><p>When the grid approximates a probability density, i.e. a positive density function, approximated PDF anc CDF functions can be obtained with <a href="api/#AdaptiveDensityApproximation.get_pdf"><code>get_pdf</code></a> and <a href="api/#AdaptiveDensityApproximation.get_cdf"><code>get_cdf</code></a>. For example, consider a normal distribution:</p><pre><code class="language-julia hljs">p(x) = 1/sqrt(2*pi) * exp(-x^2/2)
grid = create_grid(LinRange(-10,10,100))
approximate_density!(grid,p)
plot(grid)</code></pre><img src="index-9126d1f4.svg" alt="Example block output"/><p>Then the approximated CDF is</p><pre><code class="language-julia hljs">cdf = get_cdf(grid)

plot(cdf, fill = 0, legend = :none)</code></pre><img src="index-26f67980.svg" alt="Example block output"/><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The functions <a href="api/#AdaptiveDensityApproximation.get_pdf"><code>get_pdf</code></a> and <a href="api/#AdaptiveDensityApproximation.get_cdf"><code>get_cdf</code></a> do not check if the weights of the blocks are positive. Negative values can lead to unexpected behavior, e.g. division by zero because of the normalization <code>1/sum(weights)</code>.</p></div></div><h2 id="Simple-2-dim-example"><a class="docs-heading-anchor" href="#Simple-2-dim-example">Simple 2-dim example</a><a id="Simple-2-dim-example-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-2-dim-example" title="Permalink"></a></h2><p>In general, all methods introduced so far are defined for grids of arbitrary dimensions (except for plotting recipes):</p><pre><code class="language-julia hljs">using AdaptiveDensityApproximation, Plots

grid = create_grid([0,pi,2*pi],[0,pi,2pi])
f(x) = sin(x[1])^2 + cos(x[2])^2

animation = @animate for i in 1:100
	plot(grid)
	approximate_density!(grid,f)
	refine!(grid)
end
gif(animation, fps = 4)</code></pre><p><img src="images/simple-2-dim-example.gif" alt/></p><p>It is possible to get a lower-dimensional slice from a higher-dimensional grid with <a href="api/#AdaptiveDensityApproximation.get_slice"><code>get_slice</code></a>. For the previous 2-dim example a slice along the <code>x</code>-axis at <code>y=3</code> can be obtained as follows:</p><pre><code class="language-julia hljs">slice = get_slice(grid,[nothing,3])
plot(slice)</code></pre><img src="index-40c5aede.svg" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="plotting_basics/">Plotting basics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Sunday 21 July 2024 23:16">Sunday 21 July 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

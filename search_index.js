var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Create-new-grids","page":"API","title":"Create new grids","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"create_grid","category":"page"},{"location":"api/#AdaptiveDensityApproximation.create_grid","page":"API","title":"AdaptiveDensityApproximation.create_grid","text":"create_grid(axis_ticks::AbstractArray...;initial_weight = 1.0, exclude_strings = [\"\"],string_length = 10)\n\nCreate a multidimensional grid, where the axis_ticks define the corner points of the blocks.\n\nFor each dimension a separate array of axis-ticks is required. Each axis-ticks array must have at least 3 elements.\n\nKeywords\n\ninitial_weight: Initial weight for the blocks.\nexclude_strings: Strings that should not be used for the block names / keys.\nstring_length: Length for the block names / keys.\n\n\n\n\n\ncreate_grid(axis_ticks::AbstractArray;initial_weight = 1.0, exclude_strings = [\"\"],string_length = 10)\n\nCreate a one-dimensional grid where the axis_ticks define the start/end points of the intervals.\n\nThere must be at least 3 elements in the axis_ticks array.\n\nKeywords\n\ninitial_weight: Initial weight for the intervals.\nexclude_strings: Strings that should not be used for the block names / keys.\nstring_length: Length for the block names / keys.\n\n\n\n\n\n","category":"function"},{"location":"api/#Approximate-density-functions","page":"API","title":"Approximate density functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"approximate_density!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.approximate_density!","page":"API","title":"AdaptiveDensityApproximation.approximate_density!","text":"approximate_density!(grid,f::Function; mode = :center, mesh_size = 4, volume_normalization = false)\n\nApproximate the density function f with the grid, changing the weights to the function values and return the mutated grid.\n\nmode = :center: Evaluate the density function in the center of the interval/block.\nmode = :mean: Evaluate the density function at all corner points of the interval/block and use the mean value.\nmode = :mesh: Evaluate the density function at all mesh points of the interval/block and use the mean value.\nmesh_size = 4: Number of block discretization points in each dimension. Only applicable to mode = :mesh.\nvolume_normalization = false: If true the density value is normalized to the block volume (weight = value × volume).\n\n\n\n\n\n","category":"function"},{"location":"api/#Import-and-Export","page":"API","title":"Import and Export","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"export_weights","category":"page"},{"location":"api/#AdaptiveDensityApproximation.export_weights","page":"API","title":"AdaptiveDensityApproximation.export_weights","text":"export_weights(grid)\n\nReturn a one-dim array containing the weights of the intervals/blocks.\n\nThe intervals/blocks are sorted by their centers. The weights are exported in this order.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"export_all","category":"page"},{"location":"api/#AdaptiveDensityApproximation.export_all","page":"API","title":"AdaptiveDensityApproximation.export_all","text":"export_all(grid)\n\nReturn one-dimensional arrays: centers, volumes, weights.\n\nThe arrays are sorted and exported by centers.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"import_weights!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.import_weights!","page":"API","title":"AdaptiveDensityApproximation.import_weights!","text":"import_weights!(grid, weights)\n\nImport weights and return the mutated grid.\n\nThe intervals/blocks are sorted by their centers. The weights are imported in this order.\n\n\n\n\n\n","category":"function"},{"location":"api/#Refine-a-grid","page":"API","title":"Refine a grid","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"refine!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.refine!","page":"API","title":"AdaptiveDensityApproximation.refine!","text":"refine!(grid::Union{OneDimGrid,Grid}; block_variation::Function = default_block_variation, selection::Function = maximum, split_weights::Bool = false)\n\nSubdivide intervals/blocks in a grid based on the respective variations. Return the mutated grid and the indices of subdivided (i.e. new) blocks (indices w.r.t arrays obtained from export_weights and export_all).\n\nBy default the variation of a block is the largest difference in weights w.r.t. to its neighbors. The blocks to be subdivided are those that have the largest variation. If several blocks have the same variation, all those blocks are subdivided.\n\nChanging the selection of blocks\n\nblock_variation: Function to calculate the variation value for a block. Must use the following signature (block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights).\nselection: Function to select the appropriate variation value(s) from. Must have the signature (variations)  where variations is a one-dim array of the variation values.\n\nChanging the weight splitting\n\nBy default, the subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"subdivide!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.subdivide!","page":"API","title":"AdaptiveDensityApproximation.subdivide!","text":"subdivide!(grid::Union{OneDimGrid,Grid},block_name::AbstractString; split_weights::Bool = false)\n\nSplit the block with name block_name into 2^dim sub-blocks. Return the mutated grid.\n\nChanging the weight splitting\n\nBy default, the subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).\n\n\n\n\n\n","category":"function"},{"location":"api/#Restrict-the-grid-domain","page":"API","title":"Restrict the grid domain","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"restrict_domain!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.restrict_domain!","page":"API","title":"AdaptiveDensityApproximation.restrict_domain!","text":"restrict_domain!(grid::OneDimGrid; lower::Real = -Inf,upper::Real = Inf, weight_distribution::Symbol = :none)\n\nRestrict a grid to the domain defined by lower and upper.\n\nweight_distribution = :linear: A split block gets the weight scaled to the proportion of the block within the domain.\nweight_distribution = :log: A split block gets the weight scaled to the proportion of the block, in a logarithmic scale, within the domain.\n\n\n\n\n\nrestrict_domain!(grid::Grid;lower = [-Inf,...,-Inf], upper = [Inf,...,Inf], weight_distribution::Symbol = :none)\n\nRestrict a grid to the domain defined by lower and upper.\n\nweight_distribution = :linear: A split block gets the weight scaled to the proportion of the block within the domain.\nweight_distribution = :log: A split block gets the weight scaled to the proportion of the block, in a logarithmic scale, within the domain.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"select_indices","category":"page"},{"location":"api/#AdaptiveDensityApproximation.select_indices","page":"API","title":"AdaptiveDensityApproximation.select_indices","text":"select_indices(grid::OneDimGrid; lower::Real=-Inf,upper::Real=Inf)\n\nReturn indices of intervals with centers between lower and upper. The indices correspond to the exported arrays centers, volumes and weights from export_weights and export_all.\n\n\n\n\n\nselect_indices(grid::Grid; lower= [-Inf,...,-Inf],upper=[Inf, ..., Inf])\n\nReturn indices of intervals with centers between lower and upper. The indices correspond to the exported arrays centers, volumes and weights from export_weights and export_all.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simple-calculations","page":"API","title":"Simple calculations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sum(::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.sum-Tuple{Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.sum","text":"sum(grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the sum of all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"sum(::Function,::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.sum-Tuple{Function, Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.sum","text":"sum(f::Function,grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the sum of f(weight) for all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"prod(::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.prod-Tuple{Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.prod","text":"prod(grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the product of all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"prod(::Function,::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.prod-Tuple{Function, Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.prod","text":"prod(f::Function,grid::Union{OneDimGrid, Grid}; lower = nothing, upper = nothing, weight_distribution::Symbol = :none)\n\nReturn the product of f(weight) for all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"integrate","category":"page"},{"location":"api/#AdaptiveDensityApproximation.integrate","page":"API","title":"AdaptiveDensityApproximation.integrate","text":"integrate(grid)\n\nReturn the sum of volume × weight for the intervals/blocks.\n\nWhen the grid approximates a density φ with the weights of the intervals/blocks, integrate(grid) approximates the integral of the density over the grid domain: ∫_grid φ dV.\n\n\n\n\n\n","category":"function"},{"location":"api/#Integral-models","page":"API","title":"Integral models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"integral_model","category":"page"},{"location":"api/#AdaptiveDensityApproximation.integral_model","page":"API","title":"AdaptiveDensityApproximation.integral_model","text":"integral_model(grid,f::Function, g::Function = f)\n\nCreate a model for the integral ∫_grid f(x,y,φ(y),...) dy. Returns\n\nmodel function: (x,λ,args...) -> ∑_i block[i].volume × f(x,block[i].center,λ[i],args...)\ninitial parameter based on block weights: λ_0 = [block.weight for block in grid]\ncomponents of the sum as array of functions: [(x,λ,args...) -> block[i].volume × g(x,block[i].center,λ[i],args...) for i]\n\nThe functions f and g should have the arguments (x,center,weight,args...).  \n\nPartial derivatives\n\nThe optional function g can be used to obtain the partial derivatives of the model function w.r.t. λ as array of functions. For this, construct g such that\n\ng(x,c,w) = ∂_w f(x,c,w)\n\n\n\n\n\n","category":"function"},{"location":"api/#Numeric-PDF-and-CDF","page":"API","title":"Numeric PDF and CDF","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_pdf","category":"page"},{"location":"api/#AdaptiveDensityApproximation.get_pdf","page":"API","title":"AdaptiveDensityApproximation.get_pdf","text":"get_pdf(grid;normalize::Bool = true)\n\nReturn the discrete empirical pdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If normalize = true the values are normalized s.t. the sum of all values is 1.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_cdf","category":"page"},{"location":"api/#AdaptiveDensityApproximation.get_cdf","page":"API","title":"AdaptiveDensityApproximation.get_cdf","text":"get_cdf(grid;normalize::Bool = true)\n\nReturn the discrete empirical cdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If normalize = true the values are normalized s.t. the sum of all values is 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#Grid-slices","page":"API","title":"Grid slices","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_slice","category":"page"},{"location":"api/#AdaptiveDensityApproximation.get_slice","page":"API","title":"AdaptiveDensityApproximation.get_slice","text":"get_slice(grid::Grid, slice_selection)\n\nReturn a grid of blocks (from grid) that intersect with a slice defined by slice_selection.\n\nFor example: the y-axis is defined by slice_selection = [0,nothing,0], the y-z-plane at x = 5 is defined by slice_selection = [5,nothing,nothing], etc..\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"dimension","category":"page"},{"location":"api/#AdaptiveDensityApproximation.dimension","page":"API","title":"AdaptiveDensityApproximation.dimension","text":"dimension(grid)\n\nReturn the dimension of the grid. \n\n\n\n\n\n","category":"function"},{"location":"#AdaptiveDensityApproximation","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"","category":"section"},{"location":"#About","page":"AdaptiveDensityApproximation","title":"About","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"This package introduces the Grid and OneDimGrid types that approximate density functions. The grids can be refined adaptively, i.e. depending on the  location of the strongest density variation. Simple calculations like sums and products of approximated coefficients and integrals of approximated densities are implemented.","category":"page"},{"location":"#Installation","page":"AdaptiveDensityApproximation","title":"Installation","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"This package is not in the general registry and needs to be installed from the GitHub repository by:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using Pkg\nPkg.add(url=\"https://github.com/AntibodyPackages/AdaptiveDensityApproximation\")","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"After the installation, the package can be used like any other package:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Plotting grids\nThis package does not include any plotting methods, to reduce the dependencies. However, the package AdaptiveDensityApproximationRecipes contains plotting recipes for Plots.jl. Again, the package is not in the general registry and needs to be installed from the GitHub repository:using Pkg\nPkg.add(url=\"https://github.com/AntibodyPackages/AdaptiveDensityApproximationRecipes\")","category":"page"},{"location":"#1-dim-example","page":"AdaptiveDensityApproximation","title":"1-dim example","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In the following, the methods of this package are illustrated on simple, 1-dimensional examples. In some but not all cases tips and additional information are given. For a full documentation of the methods, see the API","category":"page"},{"location":"#Construct-grid-and-approximate-densities","page":"AdaptiveDensityApproximation","title":"Construct grid and approximate densities","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The first step is to create a new one-dimensional grid. For this, axis-ticks need to be defined, i.e. the start/endpoints of the intervals:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation, AdaptiveDensityApproximationRecipes, Plots\ngrid = create_grid(LinRange(0,2*pi,10))","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The grid can be used to approximate a function f with approximate_density!(grid,f):","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"approximate_density!(grid,sin)\nplot(grid)\nplot!(sin,color = :red, xlims = [0,2*pi], linewidth = 3)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Approximation options\nThe density is approximated by evaluating the function f at the center points of the grid. But in some cases, it can be desireable to approximate the density using different evaluation points. The following keywords allow to modify the approximation points:mode = :mean: Use the average from the endpoints of the interval / corner points of the block.\nmode = :mesh: Use the average from a mesh of intermediate points.\nmesh_size = n: If mode = :mesh use n intermediate points (per dimension). The default is 4.It is also possible to approximate the area under the graph of a density (function value × block volume) by using volume_normalization = true.","category":"page"},{"location":"#Accessing-information-of-the-grid","page":"AdaptiveDensityApproximation","title":"Accessing information of the grid","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Essentially, a grid is just a collection of values (the weights), together with location information (the blocks of the grid). This data can be exported to allow for a convenient implementation of advanced calculations not covered by this package. The weights can be retrieved by","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"export_weights(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Alternatively, the full information can be exported:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"centers, volumes, weights = export_all(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The reverse direction, the import of weights is is also possible (at least for the weights):","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"import_weights!(grid, collect(1:9))\nplot(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Order of blocks\nFor export and import, the intervals/blocks are ordered by their center point. For multidimensional grids, the order is component wise (first dimension precedes second dimension precedes third dimension ...).","category":"page"},{"location":"#Refine-the-grid","page":"AdaptiveDensityApproximation","title":"Refine the grid","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The grid can be refined (subdividing the blocks that have the largest weight differences to their neighbors) with:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"refine!(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Info\nA block is subdivided into 2^dim equally-sized subdividing blocks. E.g. an interval is split in the middle into two intervals, a square is split into 4 quatring squares, etc.. ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The functions approximate_density! and refine! can be used together in a loop to refine the grid adaptively.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid([0,pi/2,pi,3*pi/2,2*pi])\n\nanimation = @animate for i in 1:30\n\tplot(grid)\n\tapproximate_density!(grid,sin)\n\trefine!(grid)\nend\ngif(animation,fps=2)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Custom variation and block selection\nThe refine process is a two-step process. First, each block is assigned a variation value. The default variation is the largest absolut weight difference to the neighboring blocks. Then, based on the variation values, the blocks that will be subdivided further are selected (largest variation value by default). It is possible to redefine the block variation assignment and the selection:block_variation: Function to calculate the variation value for a block. Must use the following signature (block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights).\nselection: Function to select the appropriate variation value(s) from. Must have the signature (variations)  where variations is a one-dim array of the variation values.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Weight splitting\nThe subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).","category":"page"},{"location":"#Restriction-of-grid-domain","page":"AdaptiveDensityApproximation","title":"Restriction of grid domain","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"For some applications it can be useful to restrict a grid (temporarily) for certain calculations. Consider, for example, a grid that approximates x->x^2 on the domain [-1,1]:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid(LinRange(-1,1,50))\napproximate_density!(grid,x-> x^2)\nplot(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A reasonable domain restriction could be to only allow positive numbers for x, i.e. to restrict the grid to [0,1]:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"restrict_domain!(grid,lower = 0)\nplot(grid)","category":"page"},{"location":"#Simple-calculations:-Sums,-products-and-integrals","page":"AdaptiveDensityApproximation","title":"Simple calculations: Sums, products and integrals","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Some simple operations are pre-defined for grids (no need to export weights, etc.). For example, the sum of the weights can easily be obtained:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"sum(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"It is also possible to apply a function to all weights before they get summed up / get multiplied together. Furthermore, the grid domain can be restricted temporarily (not mutating the grid).","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"prod(x-> log(x),grid, lower = 0.5)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A grid can also be used for the approximation of an integral. In the case of the restricted grid from above, approximating xmapsto x^2 on 01, the integral int_0^1 x^2 dx overset= frac13 is approximated:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"integrate(grid)","category":"page"},{"location":"#Advanced-calculations:-Integral-models","page":"AdaptiveDensityApproximation","title":"Advanced calculations: Integral models","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A more flexible method of integration is the construction of integral models. Consider the general model","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"\tint f(xtauvarphi(tau))  dtau","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"for a density function varphi. When the density function is approximated by a grid, i.e. by intervals I_j with centers c(I_j), volumes textvol(I_j) and heights h(I_j)approx varphi(c(I_j)), the model can be approximated with","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"\tint f(xtauvarphi(tau))  dtau approx sum_j f(xc(I_j) h(I_j)ldots)cdot textvol(I_j)  ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In general, the implementation of such a model requires a function f(x,τ,φ(τ),...) and a grid that approximates the density φ. The model can then be obtained with integral_model(grid,f). More precisely:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"<div style=\" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px \">","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"@doc integral_model #hide","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"</div> <br>","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"For example, consider f(x,τ,φ(τ)) = cos(τ * x) * φ(τ) for φ(τ) = sin(τ) on [0,2π]:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"int_0^2pi cos(taucdot x)  cdot textsin(tau)  dtau  ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In particular, it holds that:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"int_0^2pi cos(taucdot 1)  cdot textsin(tau)  dtau = 0 ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid(LinRange(0,2*pi,30))\napproximate_density!(grid,sin)\nf(x,τ,φ) = cos(τ*x)*φ\nmodel,weights, components = integral_model(grid,f)\nmodel(1,weights)","category":"page"},{"location":"#Numeric-PDF-and-CDF","page":"AdaptiveDensityApproximation","title":"Numeric PDF and CDF","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"When the grid approximates a probability density, i.e. a positive density function, numeric PDF anc CDF functions can be obtained as julia functions.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"p(x) = 1/sqrt(2*pi) * exp(-x^2/2)\ngrid = create_grid(LinRange(-10,10,100))\napproximate_density!(grid,p)\nplot(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The numeric pdf can be obtained with ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"<div style=\" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px \">","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"@doc get_pdf #hide","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"</div> <br>","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The numeric cdf can be obtained with ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"<div style=\" border-style: solid; border-width: 1px; border-radius: 5px; padding: 10px \">","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"@doc get_cdf #hide","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"</div> <br>","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"For example:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"cdf = get_cdf(grid)\n\nplot(cdf, fill = 0, legend = :none)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"warning: Warning\nThe function get_pdf and get_cdf do not check if the weights of the blocks are positive. Negative values can lead to unexpected behavior, e.g. division by zero because of the normalization 1/sum(weights).","category":"page"},{"location":"#Simple-2-dim-example","page":"AdaptiveDensityApproximation","title":"Simple 2-dim example","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In general, the methods introduced so far are defined for grids of arbitrary dimensions (except for plotting recipes):","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation, Plots\n\ngrid = create_grid([0,pi,2*pi],[0,pi,2pi])\nf(x) = sin(x[1])^2 + cos(x[2])^2\n\nanimation = @animate for i in 1:100\n\tplot(grid)\n\tapproximate_density!(grid,f)\n\trefine!(grid)\nend\ngif(animation, fps = 4)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"(Image: )","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"It is possible to get a lower-dimensional slice from a higher-dimensional grid (slice along the x-axis at y=3 in this case):","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid([0,pi,2*pi],[0,pi,2pi]) #hide\nf(x) = sin(x[1])^2 + cos(x[2])^2 #hide\n\nfor i in 1:100 #hide\n\tapproximate_density!(grid,f) #hide\n\trefine!(grid) #hide\nend #hide\n\nslice = get_slice(grid,[nothing,3])\nplot(slice)","category":"page"}]
}

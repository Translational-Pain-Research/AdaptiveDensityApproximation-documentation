var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Create-new-grids","page":"API","title":"Create new grids","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"create_grid","category":"page"},{"location":"api/#AdaptiveDensityApproximation.create_grid","page":"API","title":"AdaptiveDensityApproximation.create_grid","text":"create_grid(axis_ticks::AbstractArray...; \n\tinitial_weight = 1.0, \n\texclude_strings = [\"\"], \n\tstring_length = 10\n)\n\nCreate a multidimensional grid, where the axis_ticks define the corner points of the blocks.\n\nFor each dimension a separate array of axis-ticks is required. Each axis-ticks array must have at least 3 elements.\n\nKeywords\n\ninitial_weight: Initial weight for the blocks.\nexclude_strings: Strings that will not be used for the block names / keys.\nstring_length: Length for the block names / keys.\n\nExamples\n\njulia> create_grid([1,2,3],[1,2,3],[1,2,3])\n\njulia> create_grid(LinRange(0,1,10),LinRange(0,100,100))\n\n\n\n\n\ncreate_grid(axis_ticks::AbstractArray;\n\tinitial_weight = 1.0, \n\texclude_strings = [\"\"],\n\tstring_length = 10\n)\n\nCreate a one-dimensional grid where the axis_ticks define the start/end points of the intervals.\n\nThere must be at least 3 elements in the axis_ticks array.\n\nKeywords\n\ninitial_weight: Initial weight for the intervals.\nexclude_strings: Strings that will not be used for the block names / keys.\nstring_length: Length for the block names / keys.\n\nExamples\n\njulia> create_grid([1,2,3,4])\n\njulia> create_grid(LinRange(1,10,100))\n\n\n\n\n\n","category":"function"},{"location":"api/#Approximate-density-functions","page":"API","title":"Approximate density functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"approximate_density!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.approximate_density!","page":"API","title":"AdaptiveDensityApproximation.approximate_density!","text":"approximate_density!(grid::Union{OneDimGrid,Grid},f::Function; \n\tmode = :center,\n\tmesh_size = 4,\n\tvolume_normalization = false\n)\n\nApproximate the density function f with the grid, changing the weights to the function values and return the mutated grid.\n\nmode = :center: Evaluate the density function in the center of the interval/block.\nmode = :mean: Evaluate the density function at all corner points of the interval/block and use the mean value.\nmode = :mesh: Evaluate the density function at all mesh points of the interval/block and use the mean value.\nmesh_size = 4: Number of block discretization points in each dimension. Only applicable to mode = :mesh.\nvolume_normalization = false: If true the density value is normalized to the interval length / block volume (weight = value Ã— volume).\n\n\n\n\n\n","category":"function"},{"location":"api/#Import-and-Export","page":"API","title":"Import and Export","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"export_weights","category":"page"},{"location":"api/#AdaptiveDensityApproximation.export_weights","page":"API","title":"AdaptiveDensityApproximation.export_weights","text":"export_weights(grid::Union{OneDimGrid,Grid})\n\nReturn a vector that contains the weights of the intervals/blocks.\n\nThe weights are sorted according to the center points of the intervals/blocks.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"export_all","category":"page"},{"location":"api/#AdaptiveDensityApproximation.export_all","page":"API","title":"AdaptiveDensityApproximation.export_all","text":"export_all(grid::Union{OneDimGrid,Grid})\n\nReturn the vectors: centers, volumes, weights.\n\nThe vector elements are sorted according to the center points of the intervals/blocks.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"import_weights!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.import_weights!","page":"API","title":"AdaptiveDensityApproximation.import_weights!","text":"import_weights!(grid::Union{OneDimGrid,Grid}, weights)\n\nImport weights and return the mutated grid.\n\nFor the import, the intervals/blocks are sorted according to their center points.\n\n\n\n\n\n","category":"function"},{"location":"api/#Refine-a-grid","page":"API","title":"Refine a grid","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"refine!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.refine!","page":"API","title":"AdaptiveDensityApproximation.refine!","text":"refine!(grid::Union{OneDimGrid,Grid}; \n\tblock_variation::Function = default_block_variation, \n\tselection::Function = maximum, \n\tsplit_weights::Bool = false\n)\n\nSubdivide intervals/blocks in a grid based on the respective variations. Return the mutated grid and the indices of subdivided (i.e. new) blocks (The index order is the order of export_weights and export_all).\n\nBy default the variation of a block is the largest difference of weights compared to the weights of the neighboring blocks. The blocks to be subdivided are those that have the largest variation. If several blocks have the same variation, all those blocks are subdivided.\n\nChanging the selection of blocks\n\nblock_variation: Function to calculate the variation value for a block. Must use the following signature (block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights).\nselection: Function to select the the blocks based on the variation value. Must have the signature (variations)  where variations is a one-dim array of the variation values.\n\nChanging the weight splitting\n\nBy default, the subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).\n\nExample\n\nSelect the block(s) with the smallest possible weight difference to its neighbors:\n\nmin_difference(c,v,w,C,V,W) = minimum(abs.(w .- W))\nrefine!(grid, block_variation= min_difference, selection = minimum)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"subdivide!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.subdivide!","page":"API","title":"AdaptiveDensityApproximation.subdivide!","text":"subdivide!(grid::Union{OneDimGrid,Grid},block_name::AbstractString; \n\tsplit_weights::Bool = false\n)\n\nSplit the block with name block_name into 2^dim sub-blocks. Return the mutated grid.\n\nChanging the weight splitting\n\nBy default, the subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).\n\n\n\n\n\n","category":"function"},{"location":"api/#Restrict-the-grid-domain","page":"API","title":"Restrict the grid domain","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"restrict_domain!","category":"page"},{"location":"api/#AdaptiveDensityApproximation.restrict_domain!","page":"API","title":"AdaptiveDensityApproximation.restrict_domain!","text":"restrict_domain!(grid::OneDimGrid; \n\tlower::Real = -Inf,\n\tupper::Real = Inf, \n\tweight_distribution::Symbol = :none\n)\n\nRestrict the domain of a grid to the domain defined by lower and upper.\n\nweight_distribution = :linear: If a block gets split up, the weight is rescaled w.r.t. the proportion of the block within the domain.\nweight_distribution = :log: If a block gets split up, the weight is rescaled w.r.t. the proportion of the block within the domain, as it appears in a logarithmically scaled plot.\n\n\n\n\n\nrestrict_domain!(grid::Grid;\n\tlower = [-Inf,...,-Inf],\n\tupper = [Inf,...,Inf],\n\tweight_distribution::Symbol = :none\n)\n\nRestrict the domain of a grid to the domain defined by lower and upper.\n\nweight_distribution = :linear: If a block gets split up, the weight is rescaled w.r.t. the proportion of the block within the domain.\nweight_distribution = :log: If a block gets split up, the weight is rescaled w.r.t. the proportion of the block within the domain, as it appears in a logarithmically scaled plot.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"select_indices","category":"page"},{"location":"api/#AdaptiveDensityApproximation.select_indices","page":"API","title":"AdaptiveDensityApproximation.select_indices","text":"select_indices(grid::OneDimGrid; lower::Real=-Inf,upper::Real=Inf)\n\nReturn indices of intervals with centers between lower and upper. The index order is the order of export_weights and export_all\n\n\n\n\n\nselect_indices(grid::Grid; lower= [-Inf,...,-Inf],upper=[Inf, ..., Inf])\n\nReturn indices of intervals with centers between lower and upper. The index order is the order of export_weights and export_all.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simple-calculations","page":"API","title":"Simple calculations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"sum(::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.sum-Tuple{Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.sum","text":"sum(grid::Union{OneDimGrid, Grid}; \n\tlower = nothing, \n\tupper = nothing, \n\tweight_distribution::Symbol = :none\n)\n\nReturn the sum of all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"sum(::Function,::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.sum-Tuple{Function, Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.sum","text":"sum(f::Function,grid::Union{OneDimGrid, Grid}; \n\tlower = nothing, \n\tupper = nothing, \n\tweight_distribution::Symbol = :none\n)\n\nReturn the sum of f(weight) for all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 0 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"prod(::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.prod-Tuple{Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.prod","text":"prod(grid::Union{OneDimGrid, Grid}; \n\tlower = nothing,\n\tupper = nothing,\n\tweight_distribution::Symbol = :none\n)\n\nReturn the product of all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"prod(::Function,::Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid})","category":"page"},{"location":"api/#Base.prod-Tuple{Function, Union{AdaptiveDensityApproximation.Grid, AdaptiveDensityApproximation.OneDimGrid}}","page":"API","title":"Base.prod","text":"prod(f::Function,grid::Union{OneDimGrid, Grid};\n\tlower = nothing,\n\tupper = nothing,\n\tweight_distribution::Symbol = :none\n)\n\nReturn the product of f(weight) for all weights.\n\nlower, upper and weight_distribution can be used to restrict the domain, similar to restrict_domain!. This does not mutate the grid.\nToo restrictive boundaries (empty grid) raise a warning and the default value 1 is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"integrate","category":"page"},{"location":"api/#AdaptiveDensityApproximation.integrate","page":"API","title":"AdaptiveDensityApproximation.integrate","text":"integrate(grid)\n\nReturn the sum over all intervals/blocks of volume Ã— weight.\n\nWhen the grid weights approximate a density Ï†, integrate(grid) approximates the integral of the density over the grid domain: âˆ«_grid Ï† dV. This does not apply, if the gird weights already approximate the area/volume under the density (see volume_normalization for approximate_density!).\n\n\n\n\n\n","category":"function"},{"location":"api/#Integral-models","page":"API","title":"Integral models","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"integral_model","category":"page"},{"location":"api/#AdaptiveDensityApproximation.integral_model","page":"API","title":"AdaptiveDensityApproximation.integral_model","text":"integral_model(grid,f::Function, g::Function = f)\n\nCreate an approximation for the integral model âˆ«_grid f(x,y,Ï†(y),args...) dy. Returns\n\nthe approximated model (function).\nthe grid weights as initial parameters (array).\nindividual block functions using g instead of f (array of functions).\n\nLet the grid approximate the density Ï†. That is, the weight of blocks are characteristic density values for the blocks. For example, Î»_i = Ï†(c_i) where c_i are the centers of the blocks. Furthermore let V_i denote the volumes of the blocks. Then:\n\nthe returned approximated model is: (x,Î»,args...) -> âˆ‘_i V_i â‹… f(x,c_i,Î»_i,...)\nthe returned parameters are: [Î»_1,...,Î»_n]\nthe individual block functions are: [(x,Î»,args...) -> V_i â‹… g(x,c_i,Î»_i,...) for i = 1:number_of_blocks]\n\nUsing an optional integral kernel function g, allows to obtain modified functions for the individual blocks (if g is not provided the default case is g=f). The functions f and g should have the arguments (x,center,weight,args...). This can be useful if one wants to obtain partial derivatives of the approximated model. For further details see Advanced calculations: Integral models \n\n\n\n\n\n","category":"function"},{"location":"api/#Numeric-PDF-and-CDF","page":"API","title":"Numeric PDF and CDF","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_pdf","category":"page"},{"location":"api/#AdaptiveDensityApproximation.get_pdf","page":"API","title":"AdaptiveDensityApproximation.get_pdf","text":"get_pdf(grid::Union{OneDimGrid,Grid}; normalize::Bool = true)\n\nReturn the discrete empirical pdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If normalize = true the values are normalized s.t. the sum of all values is 1.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_cdf","category":"page"},{"location":"api/#AdaptiveDensityApproximation.get_cdf","page":"API","title":"AdaptiveDensityApproximation.get_cdf","text":"get_cdf(grid::Union{OneDimGrid,Grid};normalize::Bool = true)\n\nReturn the discrete empirical cdf function of a grid. For this, the grid is understood as histogram, where the blocks are the bins, and the weights are the corresponding values. If normalize = true the values are normalized s.t. the sum of all values is 1.\n\n\n\n\n\n","category":"function"},{"location":"api/#Grid-slices","page":"API","title":"Grid slices","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_slice","category":"page"},{"location":"api/#AdaptiveDensityApproximation.get_slice","page":"API","title":"AdaptiveDensityApproximation.get_slice","text":"get_slice(grid::Grid, slice_selection)\n\nReturn a grid of blocks (from grid) that intersect with a slice defined by slice_selection.\n\n3-dim example: the y-axis is defined by slice_selection = [0,nothing,0], the y-z-plane at x = 5 is defined by slice_selection = [5,nothing,nothing], etc..\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"dimension","category":"page"},{"location":"api/#AdaptiveDensityApproximation.dimension","page":"API","title":"AdaptiveDensityApproximation.dimension","text":"dimension(grid::Union{OneDimGrid,Grid})\n\nReturn the dimension of the grid. \n\n\n\n\n\n","category":"function"},{"location":"plotting_keywords/#Plotting-options","page":"Plotting options","title":"Plotting options","text":"","category":"section"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"Most keywords from Plots.jl are supported. Furthermore, the following options can be used to change the appearance of gird plots (using the grids from Plotting basics for the examples):","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"using AdaptiveDensityApproximation, AdaptiveDensityApproximationRecipes, Plots #hide\none_dim_grid = create_grid(LinRange(0,2*pi,20)) #hide\napproximate_density!(one_dim_grid,sin) #hide\ntwo_dim_grid = create_grid(LinRange(0,2*pi,20),LinRange(0,2pi,20)) #hide\napproximate_density!(two_dim_grid, x -> sin(x[1])^2 + cos(x[2])^2) #hide\nnothing #hide","category":"page"},{"location":"plotting_keywords/#Fill-colors","page":"Plotting options","title":"Fill colors","text":"","category":"section"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"The fill color of each interval/block is determined from a color function that can be specified with the fill_color_function keyword. To illustrate the principle, consider the default color function:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"function default_color_function(current_weight,grid_weights)\n\t# Get the weight range.\n\tmin_w, max_w  = extrema(grid_weights)\n\tif min_w == max_w\n\t\topacity = 1\n\telse\n\t\t# Calculate the proportion of the current_weight.\n\t\topacity = (current_weight - min_w)/(max_w - min_w)\n\tend\n\treturn (opacity,\"Midnight Blue\")\nend","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"The color function will be applied internally to every interval/block and must accept two arguments: (val,Arr), where val will be the weight of the current interval/block and where Arr will be the vector of all wights in the grid. The color function must return two arguments, an opacity (number between 0 and 1) and a color compatible with Plots.jl.","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"As example, we can implement the color gradient :thermal form ColorsSchemes.jl:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"using ColorSchemes\n\nthermal = cgrad(:thermal)\n\nfunction thermal_function(current_weight,grid_weights)\n\tmin_w, max_w  = extrema(grid_weights)\n\tweight_proportion = (current_weight - min_w)/(max_w-min_w)\n\treturn (1,thermal[weight_proportion])\nend\nnothing #hide","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"To apply the new color function, we set fill_color_function = thermal_function for the plotting:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(two_dim_grid, fill_color_function = thermal_function)","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"At the moment, there is no way to add automatically generated colorbars to the plot. As workaround, the colorbars can be created manually, e.g. as explained in Colorbars","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"The color function can also be used for a OneDimGrid:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(one_dim_grid, fill_color_function = thermal_function)","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"Since the bar height for OneDimGrid-plots already depicts the weight for each interval, a single fill color can be sufficient: ","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(one_dim_grid, fill_color_function = (w,W) -> (1,\"Midnight Blue\"))","category":"page"},{"location":"plotting_keywords/#Line-colors","page":"Plotting options","title":"Line colors","text":"","category":"section"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"The color of the lines that separate the intervals/blocks can be changed with the line_color_function keyword. It works in the same way as fill_color_function:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(two_dim_grid, line_color_function = (w,W) ->  (1,\"dark red\"))","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(one_dim_grid, line_color_function = (w,W) ->  (1,\"dark red\"))","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"It is possible to pass the same function to both line_color_function and fill_color_function. This allows to hide the lines that separate the intervals/blocks. ","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(one_dim_grid, line_color_function = (w,W) -> (1,\"Midnight Blue\"), \n\tfill_color_function = (w,W) -> (1,\"Midnight Blue\"))","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"Since the intervals/blocks are plotted one after another, interval/block-specific line colors can lead to visual artifacts. This effect can be exaggerated with increased line widths and the thermal_function that was defined in Fill colors:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(two_dim_grid,linewidth = 6, line_color_function = thermal_function, \n\tfill_color_function = thermal_function)","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"Reducing the line width, on the other hand, can fix the visual artifacts","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(two_dim_grid, linewidth = 0.5, line_color_function = thermal_function, \n\tfill_color_function = thermal_function)","category":"page"},{"location":"plotting_keywords/#OneDimGrid-bar-height","page":"Plotting options","title":"OneDimGrid bar height","text":"","category":"section"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"The default plotting behavior for OneDimGrid-plots and Grid-plots differs, since one-dimensional grids can use the free y-axis to depict the weights of intervals. This behavior can be changed with the height_function that determines the bar-height, based on the weight of the corresponding interval. The default function is x->x, which produces bar heights equal to the respective interval weights.","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"To obtain OneDimGrid-plots that behave like Grid-plots, a constant height value needs to be set:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(one_dim_grid, height_function = x->1)","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"The height_function allows to separate the bar heights from the actual gird weights. For example, the absolute value can be plotted, but the true weight value can be used for the fill colors (using the thermal_function defined in Fill colors):","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(one_dim_grid, height_function = x->abs(x), fill_color_function = thermal_function)","category":"page"},{"location":"plotting_keywords/#OneDimGrid-along-the-y-axis","page":"Plotting options","title":"OneDimGrid along the y-axis","text":"","category":"section"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"A OneDimGrid can be plotted along the y-axis by setting vertical=true:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(one_dim_grid, vertical =true)","category":"page"},{"location":"plotting_keywords/#Colorbars","page":"Plotting options","title":"Colorbars","text":"","category":"section"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"Currently, there is no way to create automatic colorbars. As workaround, a colorbar can be created manually with a OneDimGrid-plot. For the example, we use the 2-dim example grid two_dim_grid and the thermal_function that was defined in Fill colors.","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"First, we extract the weight range from two_dim_grid.","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"weight_range = extrema(export_weights(two_dim_grid))","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"Then, we create a new 1-dim grid color_grid that has weight_range as domain, and set up 100 intervals to get a continuous color bar:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"# 101 discretization points -> 100 intervals \ncolor_grid = create_grid(LinRange(weight_range...,101))\nnothing #hide","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"Next, we import 100 increasing, linearly spaced wights (e.g. LinRange(0,1,100)):","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"import_weights!(color_grid, LinRange(0,1,100))\nnothing #hide","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"To plot the colorbar, we use the following options","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"thermal_function for line_color_function and fill_color_function\nheight_function = x-> 1 to obtain a bar\nyaxis=false to disable the y-axis.","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"plot(color_grid, fill_color_function = thermal_function, \n\tline_color_function = thermal_function, \n\theight_function = x-> 1, yaxis = false)","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"In this form, the colorbar is not very useful.  To plot the colorbar next to the two_dim_grid plot, we can use subplots and layouts:","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"p1 = plot(two_dim_grid, fill_color_function = thermal_function)\np2 = plot(color_grid, fill_color_function = thermal_function, \n\tline_color_function = thermal_function, \n\theight_function = x-> 1, size = (600,50), yaxis = false)\nplot(p1,p2, layout = @layout [a{0.9h}; b])","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"In the same way, a vertical colorbar can be created (using Measures.jl to adjust the margins):","category":"page"},{"location":"plotting_keywords/","page":"Plotting options","title":"Plotting options","text":"using Measures\np1 = plot(two_dim_grid, fill_color_function = thermal_function)\np2 = plot(color_grid, fill_color_function = thermal_function, \n\tline_color_function = thermal_function, \n\theight_function = x-> 1, vertical = true,  \n\txaxis = false, left_margin=5mm)\nplot(p1,p2, layout = @layout [a{0.9w} b])","category":"page"},{"location":"plotting_basics/#Plotting-grids","page":"Plotting basics","title":"Plotting grids","text":"","category":"section"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"AdaptiveDensityApproximationRecipes.jl defines plotting recipes for Plots.jl, providing simple visualizations for 2-dim Grid objects and OneDimGrid objects.","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"If the registry Translational-Pain-Julia-Registry is installed, AdaptiveDensityApproximationRecipes.jl can be installed like any other package","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"using Pkg\nPkg.add(\"AdaptiveDensityApproximationRecipes\")","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"Otherwise, install the Translational-Pain-Julia-Registry first","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"using Pkg\nPkg.Registry.add()\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/Translational-Pain-Research/Translational-Pain-Julia-Registry\"))","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"To illustrate the plotting of grids, a OneDimGrid object and a Grid object need to be constructed","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"using AdaptiveDensityApproximation\none_dim_grid = create_grid(LinRange(0,2*pi,20))\napproximate_density!(one_dim_grid,sin)\n\ntwo_dim_grid = create_grid(LinRange(0,2*pi,20),LinRange(0,2pi,20))\napproximate_density!(two_dim_grid, x -> sin(x[1])^2 + cos(x[2])^2)\nnothing #hide","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"With AdaptiveDensityApproximationRecipes.jl and Plots.jl, the grids can easily be plotted","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"using AdaptiveDensityApproximationRecipes, Plots\nplot(one_dim_grid)","category":"page"},{"location":"plotting_basics/","page":"Plotting basics","title":"Plotting basics","text":"plot(two_dim_grid)","category":"page"},{"location":"#AdaptiveDensityApproximation","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"","category":"section"},{"location":"#About","page":"AdaptiveDensityApproximation","title":"About","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"AdaptiveDensityApproximation.jl introduces the types OneDimGrid andGrid that can be refined adaptively for the approximation of density functions. Simple calculations are implemented, e.g. the sum and product of approximated density coefficients or a rudimentary numerical integration of approximated densities. Integral models can be approximated for the inference of densities. In case of probability densities, empirical PDF and CDF functions can be constructed.","category":"page"},{"location":"#Installation","page":"AdaptiveDensityApproximation","title":"Installation","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The package can be installed with the following commands","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using Pkg\nPkg.Registry.add()\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/Translational-Pain-Research/Translational-Pain-Julia-Registry\"))\nPkg.add(\"AdaptiveDensityApproximation\")","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Since the package is not part of the General registry the commands install the additional registry Translational-Pain-Julia-Registry first.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"After the installation, the package can be used like any other package:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In the following, the methods of this package are illustrated with simple, 1-dimensional examples. For a full documentation of the methods, see the API","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Plotting grids\nThis package does not include any plotting methods, to reduce the dependencies. However, the AdaptiveDensityApproximationRecipes.jl contains plotting recipes for Plots.jl. Assuming that the Translational-Pain-Julia-Registry is installed, the package can be installed like any other package:using Pkg\nPkg.add(\"AdaptiveDensityApproximationRecipes\")","category":"page"},{"location":"#Construct-a-grid-and-approximate-densities","page":"AdaptiveDensityApproximation","title":"Construct a grid and approximate densities","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The first step is to create a new one-dimensional grid with create_grid. For this, axis-ticks need to be defined, i.e. the start/endpoints of the intervals:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation, AdaptiveDensityApproximationRecipes, Plots\ngrid = create_grid(LinRange(0,2*pi,10))","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The grid can be used to approximate a density with approximate_density!:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"approximate_density!(grid,sin)\nplot(grid)\nplot!(sin,color = :red, xlims = [0,2*pi], linewidth = 3, label = \"sin(x)\")","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Approximation options\nA density is approximated by evaluating the density-function at the center points of the grid. But in some cases, it can be desireable to approximate the density using different evaluation points. The following keywords allow to modify the approximation points:mode = :mean: Use the average of the function values from the endpoints of the interval / corner points of the block.\nmode = :mesh: Use the average of the function values from a mesh of intermediate points.\nmesh_size = n: If mode = :mesh use n intermediate points (per dimension). The default is 4.It is also possible to approximate the area under the graph of a density (function value Ã— block volume) by using volume_normalization = true.","category":"page"},{"location":"#Accessing-information-of-the-grid","page":"AdaptiveDensityApproximation","title":"Accessing information of the grid","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Essentially, a grid is just a collection of values (the weights), together with location information (the blocks of the grid). This data can be exported to allow for a convenient implementation of advanced calculations not covered by this package. The weights can be exported with export_weights:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"export_weights(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Alternatively, the full information can be exported with export_all:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"centers, volumes, weights = export_all(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The reverse direction, the import of weights is possible with import_weights!:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"import_weights!(grid, collect(1:9))\nplot(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Order of blocks\nFor export and import, the intervals/blocks are ordered according to their center points. For multidimensional grids, the order is component wise (first dimension precedes second dimension precedes third dimension ...).","category":"page"},{"location":"#Refine-the-grid","page":"AdaptiveDensityApproximation","title":"Refine the grid","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The refine! function subdivides the blocks that have the largest weight differences to their neighbors):","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"refine!(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Info\nA block is subdivided into 2^dim equally-sized subdividing blocks. E.g. an interval is split in the middle into two intervals, a square is split into 4 quartering squares, etc.. ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The functions approximate_density! and refine! can be used together in a loop to refine the grid adaptively.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid([0,pi/2,pi,3*pi/2,2*pi])\n\nanimation = @animate for i in 1:30\n\tplot(grid)\n\tplot!(sin,color = :red, xlims = [0,2*pi], linewidth = 3, label = \"sin(x)\")\n\tapproximate_density!(grid,sin)\n\trefine!(grid)\nend\ngif(animation,fps=2)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Tip: Custom variation and block selection\nThe refine process is a two-step process. First, each block is assigned a variation value. The default variation is the largest absolut weight difference to the neighboring blocks. Then, based on the variation values, the blocks that will be subdivided further get selected (largest variation value by default). However, it is possible to redefine the block variation assignment and the selection:block_variation: Function to calculate the variation value for a block. Must use the following signature (block_center,block_volume, block_weight, neighbor_center,neighbor_volumes, neighbor_weights).\nselection: Function to select which blocks need to be refined, based on their variation values. Must have the signature (variations)  where variations is a one-dim array of the variation values.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"info: Weight splitting\nThe new subdividing blocks retain the weight of the original block. If split_weights = true, the weight of the original block is split up evenly between the subdividing blocks (i.e. divided by the number of subdividing blocks).","category":"page"},{"location":"#Restriction-of-grid-domain","page":"AdaptiveDensityApproximation","title":"Restriction of grid domain","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"For some applications it can be useful to restrict a grid. Consider, for example, a grid that approximates x->x^2 on the domain [-2,2]:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid(LinRange(-2,2,50))\napproximate_density!(grid,x->x^2)\nplot(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The grid domain can be restricted to e.g. [0,1] with restrict_domain!:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"restrict_domain!(grid,lower = 0, upper = 1)\nplot(grid)","category":"page"},{"location":"#Simple-calculations:-Sums,-products-and-integrals","page":"AdaptiveDensityApproximation","title":"Simple calculations: Sums, products and integrals","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Some simple operations are pre-defined for grids. For example, the sum and the product of the weights can easily be obtained.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"sum(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"It is also possible to apply a function to all weights before they get summed up / get multiplied together. Furthermore, the grid domain can be restricted temporarily (not mutating the grid).","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"prod(x-> log(x),grid, lower = 0.5, upper = 0.9)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A grid can also be used for the approximation of an integral. In the case of the restricted grid from above, approximating xmapsto x^2 on 01, the integral int_0^1 x^2 dx = frac13 can be approximated with integrate:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"integrate(grid)","category":"page"},{"location":"#Advanced-calculations:-Integral-models","page":"AdaptiveDensityApproximation","title":"Advanced calculations: Integral models","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"A more flexible method of integration is the construction of integral models. Consider the general model","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"\tint f(xyvarphi(y))  dy","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"When the density varphi is approximated by a grid, i.e. by blocks B_i with centers c_i, block volumes V_i and weights (function values) lambda_i = varphi(c_i), the model can be approximated:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"\tint f(xtauvarphi(y))  dy approx sum_i f(xc_i lambda_ildots)cdot V_i  ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"As simple example, consider f(x,y,Ï†(y)) = cos(y * x) * Ï†(y) with Ï†(y) = sin(y) for the domain [0,2Ï€]:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"int_0^2pi cos(ycdot x)  cdot textsin(y)  dy  ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"First, we construct a grid with domain [0,2Ï€] and approximate the density sin(y):","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid(LinRange(0,2*pi,30))\napproximate_density!(grid,sin)\nnothing # hide","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Next, we create the integral kernel f and create the approximated model with integral_model:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"f(x,y,Ï†) = cos(y*x)*Ï†\napprox_model,weights, block_functions = integral_model(grid,f)\nnothing # hide","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Finally, we can evaluate the model at x = 1, Î» = weights","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"approx_model(1,weights)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"The result can be checked analytically in this case:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"int_0^2pi cos(ycdot 1)  cdot textsin(y)  dy = 0 ","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: Approximated model and density estimation\nThe approximated model function approx_model  is a function of (x,weights,...), where weights are the weights of the gird. However, instead of the grid weights any other array of the same length and data type can be used as argument. This allows to estimate a density by fitting the approximated model to data.","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"tip: individual block functions and partial derivatives\nThe block_functions contain the functions for the individual blocks. That is, block_functions is an array of functionsleft(xlambdaldots) longrightarrow V_i cdot g(xc_jlambda_jldots) qquad textforquad  iquad  textinquad  1colon n_textblocks rightInstead of the integral kernel f, the optional third argument g is used: integrate_model(grid,f,g). If no third argument is provided, the default case is g=f. This optional third argument can be used to construct the partial derivatives of the approximated model w.r.t. the parameters lambda_j, by constructing g such thatg(xyvarphildots) = fracpartial f(xyvarphildots)partial varphi This leads to the following block_functions:left(xlambdaldots) longrightarrow V_i cdot left fracpartial f(xyvarphildots)partial varphiright_(xyvarphildots) = (xc_jlambda_jldots) qquad textforquad  iquad  textinquad  1colon n_textblocks rightIt can easily be checked that these functions are the partial derivatives w.r.t. the parameters lambda_j of the approximated model:fracpartialpartial lambda_j sum_i V_i f(xc_jlambda_jldots) = V_i fracpartialpartial lambda_j  f(xc_jlambda_jldots) equiv V_i cdot left fracpartial f(xyvarphildots)partial varphiright_(xyvarphildots) = (xc_jlambda_jldots)","category":"page"},{"location":"#PDF-and-CDF","page":"AdaptiveDensityApproximation","title":"PDF and CDF","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"When the grid approximates a probability density, i.e. a positive density function, approximated PDF anc CDF functions can be obtained with get_pdf and get_cdf. For example, consider a normal distribution:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"p(x) = 1/sqrt(2*pi) * exp(-x^2/2)\ngrid = create_grid(LinRange(-10,10,100))\napproximate_density!(grid,p)\nplot(grid)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"Then the approximated CDF is","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"cdf = get_cdf(grid)\n\nplot(cdf, fill = 0, legend = :none)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"warning: Warning\nThe functions get_pdf and get_cdf do not check if the weights of the blocks are positive. Negative values can lead to unexpected behavior, e.g. division by zero because of the normalization 1/sum(weights).","category":"page"},{"location":"#Simple-2-dim-example","page":"AdaptiveDensityApproximation","title":"Simple 2-dim example","text":"","category":"section"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"In general, all methods introduced so far are defined for grids of arbitrary dimensions (except for plotting recipes):","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"using AdaptiveDensityApproximation, Plots\n\ngrid = create_grid([0,pi,2*pi],[0,pi,2pi])\nf(x) = sin(x[1])^2 + cos(x[2])^2\n\nanimation = @animate for i in 1:100\n\tplot(grid)\n\tapproximate_density!(grid,f)\n\trefine!(grid)\nend\ngif(animation, fps = 4)","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"(Image: )","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"It is possible to get a lower-dimensional slice from a higher-dimensional grid with get_slice. For the previous 2-dim example a slice along the x-axis at y=3 can be obtained as follows:","category":"page"},{"location":"","page":"AdaptiveDensityApproximation","title":"AdaptiveDensityApproximation","text":"grid = create_grid([0,pi,2*pi],[0,pi,2pi]) #hide\nf(x) = sin(x[1])^2 + cos(x[2])^2 #hide\n\nfor i in 1:100 #hide\n\tapproximate_density!(grid,f) #hide\n\trefine!(grid) #hide\nend #hide\n\nslice = get_slice(grid,[nothing,3])\nplot(slice)","category":"page"}]
}
